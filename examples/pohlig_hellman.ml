open Pari

(* This line is mandatory to initialize the PARI stack, heap,
   table of primes... *)
let () = pari_init 2_000_000_000 (Unsigned.ULong.of_int 500_000)

(* Computes f() then resets the stack pointer to its original state,
   freeing up memory. *)
let clean_stack f =
  let sp = get_avma () in
  let _ = f () in
  set_avma sp

let ( let*? ) = Option.bind

(** Solves the discrete log of h to the given base where the order of the group
    is prime^valuation. *)
let pohlig_hellman_prime_power_order ~mul ~pow ~dlp_solve_prime ~base ~prime
    ~base_order_factorization h =
  let prime_power (p, _) = Integer.equal p prime in
  match Array.find_opt prime_power base_order_factorization with
  | None -> Some (Integer.of_int 0)
  | Some (prime, valuation) ->
      let proj_base = pow base Integer.(pow prime (of_int (valuation - 1))) in
      let f x k =
        let*? x = x in
        let*? log =
          dlp_solve_prime ~base:proj_base ~prime
            (pow
               (mul (pow base (Integer.neg x)) h)
               (Integer.pow prime (Integer.of_int (valuation - k - 1))))
        in
        Some Integer.(add x (mul (pow prime (of_int k)) log))
      in
      Iter.(fold f (Some (Integer.of_int 0)) (0 -- (valuation - 1)))

let pohlig_hellman ~order ~mul ~pow ~dlp_solve_prime ~base ~group_order h =
  let f base_order_factorization (prime, valuation) =
    let ord = Integer.(pow prime (of_int valuation)) in
    let n = Integer.(divexact (to_integer group_order) ord) in
    let*? intermediate_log =
      pohlig_hellman_prime_power_order ~mul ~pow ~dlp_solve_prime
        ~base:(pow base n) ~prime (pow h n) ~base_order_factorization
    in
    Some (Integer_mod.create intermediate_log ~modulo:ord)
  in
  let main () =
    if gequal (pow base (Integer.zero ())) h then Some (Integer.zero ())
    else if gequal base h then Some (Integer.of_int 1)
      (* If the order of [h] does not divide the order of the base, then
         no log exists. It is a necessary but not a sufficient condition
         for the existence of a log: h could be in a different subgroup
         that has the same order as the one generated by base. *)
    else if dvdii (order base) (order h) = 0 then None
    else
      let factors = factor group_order in
      let base_order = Integer.inj_unique_factorization_domain (order base) in
      let logs = Array.map (f (factor base_order)) factors in
      if Array.for_all Option.is_some logs then
        let logs = Vector.of_array (Array.map Option.get logs) in
        Some Integer_mod.(lift (chinese logs))
      else None
  in
  with_stack_clean_opt main

let[@inline] find_solution a b ~group_order ~base ~x ~pow =
  (* solves for x the congruence a * x = b mod n *)
  let[@inline] solve_congruence a b ~group_order =
    let gcd', s, _ = Integer.gcdext a group_order in
    if Integer.(equal (modulo b gcd') (of_int 0)) then
      let q = Integer.divexact b gcd' in
      let r = Integer.divexact group_order gcd' in
      let qs = Integer.Infix.(q * s) in
      Some
        Iter.(
          map
            (fun i -> Integer.(Infix.(qs + (of_int i * r))))
            (* gcd' < group_order, and is assumed to fit in an OCaml integer *)
            (0 -- (Integer.to_int gcd' - 1)))
    else None
  in
  let*? candidates = solve_congruence a b ~group_order in
  let is_solution n = if gequal (pow base n) x then Some n else None in
  let*? solution = Iter.find is_solution candidates in
  Some (Integer.modulo solution group_order)

let rho_pollard ~one ~mul ~pow ?start ~class_x ~group_order ~base x =
  let[@inline] f y =
    match class_x y with 1 -> mul base y | 0 -> mul y y | _ -> mul x y
  in
  with_stack_clean_opt (fun () ->
      let[@inline] g x k =
        Integer.(
          Infix.(
            match class_x x with
            | 0 -> of_int 2 * k mod group_order
            | 1 -> (k + of_int 1) mod group_order
            | _ -> k))
      in
      let[@inline] h x k =
        Integer.(
          Infix.(
            match class_x x with
            | 0 -> of_int 2 * k mod group_order
            | 1 -> k
            | _ -> (k + of_int 1) mod group_order))
      in
      let rec loop (x_k, a_k, b_k, x_2k, a_2k, b_2k) =
        let x_k, a_k, b_k, x_2k, a_2k, b_2k =
          (* if the loop is very long the PARI stack must be
              cleaned to keep here the constant memory footprint *)
          with_stack_clean6 (fun () ->
              ( f x_k,
                g x_k a_k,
                h x_k b_k,
                f (f x_2k),
                g (f x_2k) (g x_2k a_2k),
                h (f x_2k) (h x_2k b_2k) ))
        in
        if gequal x_k x_2k then
          Integer.Infix.(
            find_solution (b_2k - b_k) (a_k - a_2k) ~group_order ~base ~x ~pow)
        else loop (x_k, a_k, b_k, x_2k, a_2k, b_2k)
      in
      match start with
      | Some s -> loop s
      | None ->
          let a, b = Integer.(of_int 0, of_int 0) in
          loop (one, a, b, one, a, b))

let rho_pollard_with_retries ~one ~mul ~pow ~class_x ~group_order ~base h =
  let f ?start () =
    rho_pollard ?start ~one ~mul ~pow ~class_x ~group_order ~base h
  in
  let start ord =
    let a_k = Integer.random ord in
    let b_k = Integer.random ord in
    let x_k = mul (pow base a_k) (pow h b_k) in
    (x_k, a_k, b_k, x_k, a_k, b_k)
  in
  let rec loop () =
    match f ~start:(start group_order) () with
    | Some res -> Some res
    | None -> loop ()
  in
  match f () with Some res -> Some res | None -> loop ()

let zn_dlog ~base x =
  with_stack_clean_opt (fun () ->
      let modulo = Integer_mod.get_modulo base in
      let group_order =
        Integer.inj_unique_factorization_domain (eulerphi modulo)
      in
      let class_x x =
        Integer.(to_int (modulo (Integer_mod.lift x) (of_int 3)))
      in
      let mul = Integer_mod.mul in
      let pow = Integer_mod.pow in
      let dlp_solve_prime ~base ~prime =
        if cmpii prime (Integer.of_int 20) > 0 then
          rho_pollard_with_retries ~one:base ~mul ~pow ~class_x
            ~group_order:prime ~base
        else Integer_mod.log ~base
      in
      let*? x =
        pohlig_hellman ~order:Integer_mod.order ~pow ~mul ~dlp_solve_prime ~base
          ~group_order x
      in
      Some (Integer.modulo x Integer_mod.(order base)))

let ell_solve_dlog ~ell ~base x =
  with_stack_clean_opt (fun () ->
      let class_x x =
        let h =
          Integer.of_hex
            (Hex.of_bytes (Hacl_star.Hacl.SHA3_512.hash (gentobytes x)))
        in
        Integer.(to_int (modulo h (of_int 3)))
      in
      let group_order =
        Integer.inj_unique_factorization_domain
          (Elliptic_curve.order_elt ell base)
      in
      let mul = Elliptic_curve.add ell in
      let pow p n = Elliptic_curve.mul ell ~n ~p in
      pohlig_hellman
        ~order:(Elliptic_curve.order_elt ell)
        ~pow ~mul
        ~dlp_solve_prime:(fun ~base ~prime ->
          rho_pollard_with_retries ~one:base ~mul ~pow ~class_x
            ~group_order:prime ~base)
        ~base ~group_order x)

(* Let's test! *)
let option_eq = Option.equal gequal
let random_int bound = QCheck2.Gen.(1 -- (bound - 1))

let random_integer bound =
  let open QCheck2.Gen in
  let+ n = random_int (Integer.to_int bound) in
  Integer.of_int n

let random_prime =
  let open QCheck2.Gen in
  let* bits_amount = QCheck2.Gen.(9 -- 10) in
  let+ res = return (Integer.random_prime ~bits_amount) in
  if gequal res (Integer.of_int 2) then Integer.of_int 3 else res

let random_znelt modulo =
  let open QCheck2.Gen in
  let* x = random_integer modulo in
  return Integer_mod.(inj_group (create x ~modulo))

let random_znlog_instance =
  let open QCheck2.Gen in
  let* modulo = random_prime in
  let base = Integer_mod.(inj_group (create (Integer.of_int 2) ~modulo)) in
  let* x = random_znelt modulo in
  return (base, x)

let print_random_znlog_instance =
  QCheck2.Print.(
    comap
      (fun (base, x) -> (Integer_mod.to_string base, Integer_mod.to_string x))
      (tup2 string string))

let random_ell_elt ell ~base ~order =
  let open QCheck2.Gen in
  let* n = random_int order in
  return (Elliptic_curve.mul ell ~p:base ~n:(Integer.of_int n))

let random_ell =
  let open QCheck2.Gen in
  let* p = random_prime in
  let* x = random_integer p in
  let rec loop () =
    let* y = random_integer p in
    match
      Elliptic_curve.create
        ~a4:(Integer_mod.create_assume_prime_modulus x ~modulo:p)
        ~a6:(Integer_mod.create_assume_prime_modulus y ~modulo:p)
        ()
    with
    | Some ell ->
        let order = Elliptic_curve.order ell in
        if gequal order (Integer.of_int 1) then loop () else return ell
    | None -> loop ()
  in
  loop ()

let random_elldlog_instance =
  let open QCheck2.Gen in
  let* ell = random_ell in
  let order = Integer.to_int (Elliptic_curve.order ell) in
  let base = Elliptic_curve.random ell in
  let* x = random_ell_elt ell ~base ~order in
  return (ell, base, x)

let print_random_elldlog_instance =
  QCheck2.Print.(
    comap
      (fun (ell, base, x) ->
        ( Elliptic_curve.to_string ell,
          Elliptic_curve.to_string_elt base,
          Elliptic_curve.to_string_elt x ))
      (tup3 string string string))

let zn_dlog_test =
  QCheck2.Test.make ~count:10000 ~name:"zn_dlog"
    ~print:print_random_znlog_instance random_znlog_instance (fun (base, x) ->
      let log' = Integer_mod.log ~base x in
      let log = zn_dlog ~base x in
      option_eq log log')

let ell_dlog_test =
  QCheck2.Test.make ~count:5000 ~name:"ell_dlog"
    ~print:print_random_elldlog_instance random_elldlog_instance
    (fun (ell, base, x) ->
      let log' = Elliptic_curve.log ell ~base x in
      let log = ell_solve_dlog ~ell ~base x in
      option_eq log log')

let () =
  clean_stack (fun () ->
      QCheck_runner.run_tests ~verbose:true [ zn_dlog_test; ell_dlog_test ])
